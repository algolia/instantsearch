<!DOCTYPE html>
<html>
  <head>
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <meta charset="utf-8">
    <meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">
    <link rel="icon" href="assets/favicon.png">

    <!-- Always force latest IE rendering engine or request Chrome Frame -->
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">

    <title>instantsearch-react | Making your own widgets</title>

    <link rel="stylesheet" href="/assets/theme.css">
    <link rel="stylesheet" href="/assets/site.css">
  </head>

  <body>
    <div class="navigation">
      <div class="nav core">
        <ul>
  
    <li class="navItem">
      <a href="/index.html">Index</a>

      
    </li>
  
    <li class="navItem">
      <a href="/InstantSearch.html">InstantSearch</a>

      
    </li>
  
    <li class="navItem">
      <a href="/Internationalization.html">Internationalization</a>

      
    </li>
  
    <li class="navItem">
      <a href="/Styling.html">Styling</a>

      
    </li>
  
    <li class="navItem navItem--active">
      <a href="/Customization.html">Making your own widgets</a>

      
    </li>
  
</ul>

      </div>

      <div class="nav widgets">
        <ul>
  
    <li class="navItem">
      <a href="/CurrentFilters.html">CurrentFilters</a>

      
    </li>
  
    <li class="navItem">
      <a href="/EmptyQuery.html">EmptyQuery</a>

      
    </li>
  
    <li class="navItem">
      <a href="/Error.html">Error</a>

      
    </li>
  
    <li class="navItem">
      <a href="/HierarchicalMenu.html">HierarchicalMenu</a>

      
    </li>
  
    <li class="navItem">
      <a href="/Hits.html">Hits</a>

      
    </li>
  
    <li class="navItem">
      <a href="/HitsPerPage.html">HitsPerPage</a>

      
    </li>
  
    <li class="navItem">
      <a href="/Loading.html">Loading</a>

      
    </li>
  
    <li class="navItem">
      <a href="/Menu.html">Menu</a>

      
    </li>
  
    <li class="navItem">
      <a href="/NoResults.html">NoResults</a>

      
    </li>
  
    <li class="navItem">
      <a href="/NumericRefinementList.html">NumericRefinementList</a>

      
    </li>
  
    <li class="navItem">
      <a href="/Pagination.html">Pagination</a>

      
    </li>
  
    <li class="navItem">
      <a href="/Range.html">Range</a>

      
    </li>
  
    <li class="navItem">
      <a href="/RefinementList.html">RefinementList</a>

      
    </li>
  
    <li class="navItem">
      <a href="/ScrollTo.html">ScrollTo</a>

      
    </li>
  
    <li class="navItem">
      <a href="/SearchBox.html">SearchBox</a>

      
    </li>
  
    <li class="navItem">
      <a href="/SortBy.html">SortBy</a>

      
    </li>
  
    <li class="navItem">
      <a href="/Stats.html">Stats</a>

      
    </li>
  
    <li class="navItem">
      <a href="/Toggle.html">Toggle</a>

      
    </li>
  
</ul>

      </div>

      <div class="nav headings">
        <ul>
          
            <li class="subtitle">
              <a href="#default-widgets-connectors">Default widgets connectors</a>
            </li>
          
            <li class="subtitle">
              <a href="#stateful-widgets">Stateful widgets</a>
            </li>
          
            <li class="subtitle">
              <a href="#creating-your-own-connectors">Creating your own connectors</a>
            </li>
          
            <li class="subtitle">
              <a href="#displayname-proptypes-defaultprops">displayName, propTypes, defaultProps</a>
            </li>
          
            <li class="subtitle">
              <a href="#getprops-props-state-search-meta-">getProps(props, state, search, meta)</a>
            </li>
          
            <li class="subtitle">
              <a href="#refine-props-state-args-">refine(props, state, ...args)</a>
            </li>
          
            <li class="subtitle">
              <a href="#getsearchparameters-searchparameters-props-state-">getSearchParameters(searchParameters, props, state)</a>
            </li>
          
            <li class="subtitle">
              <a href="#getmetadata-props-state-">getMetadata(props, state)</a>
            </li>
          
        </ul>
      </div>
    </div>

    <div class="content">
      <h1 id="making-your-own-widgets">Making your own widgets</h1>
<p>While instantsearch-react already provides widgets out of the box, there are cases where you need to implement a custom feature that isn&#39;t covered by the default widget set.</p>
<h2 id="default-widgets-connectors">Default widgets connectors</h2>
<p>All default widgets have a corresponding higher-order component that acts as a connector, providing the required props to the widget.</p>
<p>Those connectors are available as named imports. Their name are composed of the <code class="CodeMirror cm-s-default">connect</code> prefix followed by the name of the particular widget they connect. For instance, the <code class="CodeMirror cm-s-default">SearchBox</code> widgets uses the <code class="CodeMirror cm-s-default">connectSearchBox</code> higher-order component under the hood in order to retrieve and refine the current query.</p>
<pre class="CodeMirror cm-s-default"><code><span class="cm-keyword">import</span> {<span class="cm-def">connectSearchBox</span>} <span class="cm-keyword">from</span> <span class="cm-string">&#39;instantsearch-react&#39;</span>;

<span class="cm-keyword">const</span> <span class="cm-def">MySearchBox</span> <span class="cm-operator">=</span> <span class="cm-def">props</span> <span class="cm-operator">=&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">input</span>
    <span class="cm-attribute">type</span>=<span class="cm-string">&quot;text&quot;</span>
    <span class="cm-attribute">value</span>={<span class="cm-variable">props</span>.<span class="cm-property">query</span>}
    <span class="cm-attribute">onChange</span>={<span class="cm-variable">e</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable">props</span>.<span class="cm-property">refine</span>(<span class="cm-variable">e</span>.<span class="cm-property">target</span>.<span class="cm-property">value</span>)}
  <span class="cm-tag cm-bracket">/&gt;</span>;

<span class="cm-comment">// `ConnectedSearchBox` renders a `MySearchBox` component that is connected to</span>
<span class="cm-comment">// the InstantSearch state, providing it with `query` and `refine` props for</span>
<span class="cm-comment">// reading and manipulating the current query of the search.</span>
<span class="cm-comment">// Note that this `ConnectedSearchBox` component will only work when rendered</span>
<span class="cm-comment">// as a child or a descendant of the `InstantSearch` component.</span>
<span class="cm-keyword">const</span> <span class="cm-def">ConnectedSearchBox</span> <span class="cm-operator">=</span> <span class="cm-variable">connectSearchBox</span>(<span class="cm-variable">MySearchBox</span>);</code></pre><h3 id="stateful-widgets">Stateful widgets</h3>
<p>While some widgets hold no state, like the <code class="CodeMirror cm-s-default">Hits</code> widget which simply renders the available hits, others do. For instance, the <code class="CodeMirror cm-s-default">SearchBox</code> widget&#39;s state is the current query.</p>
<p>When a widget is stateful, its state will get serialized and persisted to the URL. The corresponding URL parameter key can be customized via the widget&#39;s <code class="CodeMirror cm-s-default">id</code> prop.</p>
<p>Stateful widgets are also provided with <code class="CodeMirror cm-s-default">refine</code> and <code class="CodeMirror cm-s-default">createURL</code> methods. The <code class="CodeMirror cm-s-default">refine(nextState)</code> method allows the widget to edit its state, while the <code class="CodeMirror cm-s-default">createURL(nextState)</code> method allows the widget to generate a URL for the corresponding state.</p>
<pre class="CodeMirror cm-s-default"><code><span class="cm-comment">// Here&#39;s a variation on the usage of `connectSearchBox`: a component that just</span>
<span class="cm-comment">// renders a link to set the current query to &quot;cute cats&quot;.</span>
<span class="cm-comment">// By adding an `onClick` handler on top of the `href`, and cancelling the</span>
<span class="cm-comment">// default behavior of the link, we avoid making a full-page reload when the</span>
<span class="cm-comment">// user clicks on the link, while ensuring that opening the link in a new tab</span>
<span class="cm-comment">// still works.</span>
<span class="cm-keyword">const</span> <span class="cm-def">LookUpCuteCats</span> <span class="cm-operator">=</span> <span class="cm-variable">connectSearchBox</span>(<span class="cm-def">props</span> <span class="cm-operator">=&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">a</span>
    <span class="cm-attribute">href</span>={<span class="cm-variable">props</span>.<span class="cm-property">createURL</span>(<span class="cm-string">&#39;cute cats&#39;</span>)}
    <span class="cm-attribute">onClick</span>={<span class="cm-variable">e</span> <span class="cm-operator">=&gt;</span> {
      <span class="cm-variable">e</span>.<span class="cm-property">preventDefault</span>();
      <span class="cm-variable">props</span>.<span class="cm-property">refine</span>(<span class="cm-string">&#39;cute cats&#39;</span>);
    }}
  <span class="cm-tag cm-bracket">/&gt;</span>
);</code></pre><h2 id="creating-your-own-connectors">Creating your own connectors</h2>
<p>If you wish to implement features that are not covered by the default widgets connectors, you will need to create your own connector via the <code class="CodeMirror cm-s-default">createConnector</code> method. This methods takes in a descriptor of your connector with the following properties and methods:</p>
<h3 id="displayname-proptypes-defaultprops">displayName, propTypes, defaultProps</h3>
<p>Those properties are directly applied to the higher-order component. Providing a <code class="CodeMirror cm-s-default">displayName</code> is mandatory.</p>
<h3 id="getprops-props-state-search-meta-">getProps(props, state, search, meta)</h3>
<p>This method should return the props to forward to the composed component.</p>
<p><code class="CodeMirror cm-s-default">props</code> are the props that were provided to the higher-order component.</p>
<p><code class="CodeMirror cm-s-default">state</code> holds the state of all widgets, with the shape <code class="CodeMirror cm-s-default">{[widgetId]: widgetState}</code>. Stateful widgets describe the format of their state in their respective documentation entry.</p>
<p><code class="CodeMirror cm-s-default">search</code> holds the search results, search errors and search loading state, with the shape <code class="CodeMirror cm-s-default">{results: ?SearchResults, error: ?Error, loading: bool}</code>. The <code class="CodeMirror cm-s-default">SearchResults</code> type is described in the <a href="https://community.algolia.com/algoliasearch-helper-js/reference.html#searchresults">Helper&#39;s documentation</a>.</p>
<p><code class="CodeMirror cm-s-default">meta</code> is the list of metadata from all widgets whose connector defines a <code class="CodeMirror cm-s-default">getMetadata</code> method.</p>
<h3 id="refine-props-state-args-">refine(props, state, ...args)</h3>
<p>This method defines exactly how the <code class="CodeMirror cm-s-default">refine</code> prop of connected widgets affects the InstantSearch state.</p>
<p>It takes in the current props of the higher-order component, the state of all widgets, as well as all arguments passed to the <code class="CodeMirror cm-s-default">refine</code> and <code class="CodeMirror cm-s-default">createURL</code> props of stateful widgets, and returns a new state.</p>
<pre class="CodeMirror cm-s-default"><code><span class="cm-keyword">const</span> <span class="cm-def">CoolWidget</span> <span class="cm-operator">=</span> <span class="cm-variable">createConnector</span>({
  <span class="cm-property">displayName</span>: <span class="cm-string">&#39;CoolWidget&#39;</span>,

  <span class="cm-property">getProps</span>(<span class="cm-def">props</span>, <span class="cm-def">state</span>) {
    <span class="cm-comment">// Since the `queryAndPage` state entry isn&#39;t necessarily defined, we need</span>
    <span class="cm-comment">// to default its value.</span>
    <span class="cm-keyword">const</span> [<span class="cm-def">query</span>, <span class="cm-def">page</span>] <span class="cm-operator">=</span> <span class="cm-variable-2">state</span>.<span class="cm-property">queryAndPage</span> <span class="cm-operator">||</span> [<span class="cm-string">&#39;&#39;</span>, <span class="cm-number">0</span>];

    <span class="cm-comment">// Connect the underlying component to the `queryAndPage` state entry.</span>
    <span class="cm-keyword">return</span> {
      <span class="cm-property">query</span>: <span class="cm-variable-2">state</span>.<span class="cm-property">queryAndPage</span>[<span class="cm-number">0</span>],
      <span class="cm-property">page</span>: <span class="cm-variable-2">state</span>.<span class="cm-property">queryAndPage</span>[<span class="cm-number">1</span>],
    }
  },

  <span class="cm-property">refine</span>(<span class="cm-def">props</span>, <span class="cm-def">state</span>, <span class="cm-def">newQuery</span>, <span class="cm-def">newPage</span>) {
    <span class="cm-comment">// When the underlying component calls its `refine` prop, update the state</span>
    <span class="cm-comment">// with the new query and page.</span>
    <span class="cm-keyword">return</span> {
      <span class="cm-comment">// `state` represents the state of *all* widgets. We need to extend it</span>
      <span class="cm-comment">// instead of replacing it, otherwise other widgets will lose their</span>
      <span class="cm-comment">// respective state.</span>
      <span class="cm-meta">...</span><span class="cm-variable-2">state</span>,
      <span class="cm-variable">queryAndPage</span>: [<span class="cm-variable-2">newQuery</span>, <span class="cm-variable-2">newPage</span>],
    };
  },
})(<span class="cm-def">props</span> <span class="cm-operator">=&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span>
    The query is {<span class="cm-variable">props</span>.<span class="cm-property">query</span>}, the page is {<span class="cm-variable">props</span>.<span class="cm-property">page</span>}.
    {<span class="cm-comment">/*</span>
<span class="cm-comment">      Clicking on this button will update the state to:</span>
<span class="cm-comment">      {</span>
<span class="cm-comment">        ...otherState,</span>
<span class="cm-comment">        query: &#39;algolia&#39;,</span>
<span class="cm-comment">        page: 20,</span>
<span class="cm-comment">      }</span>
<span class="cm-comment">    */</span>}
    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">button</span> <span class="cm-attribute">onClick</span>={() <span class="cm-operator">=&gt;</span> <span class="cm-variable">props</span>.<span class="cm-property">refine</span>(<span class="cm-string">&#39;algolia&#39;</span>, <span class="cm-number">20</span>)} <span class="cm-tag cm-bracket">/&gt;</span>
    {<span class="cm-comment">/*</span>
<span class="cm-comment">      Clicking on this button will update the state to:</span>
<span class="cm-comment">      {</span>
<span class="cm-comment">        ...otherState,</span>
<span class="cm-comment">        query: &#39;instantsearch&#39;,</span>
<span class="cm-comment">        page: 15,</span>
<span class="cm-comment">      }</span>
<span class="cm-comment">    */</span>}
    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">button</span> <span class="cm-attribute">onClick</span>={() <span class="cm-operator">=&gt;</span> <span class="cm-variable">props</span>.<span class="cm-property">refine</span>(<span class="cm-string">&#39;instantsearch&#39;</span>, <span class="cm-number">15</span>)} <span class="cm-tag cm-bracket">/&gt;</span>
  <span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span>
);</code></pre><p>In the example above, we create a widget that reads and manipulates the <code class="CodeMirror cm-s-default">queryAndPage</code> state entry. However, we haven&#39;t described how those entries should affect the search parameters passed to the Algolia client just yet.</p>
<h3 id="getsearchparameters-searchparameters-props-state-">getSearchParameters(searchParameters, props, state)</h3>
<p>This method applies the current props and state to the provided <code class="CodeMirror cm-s-default">SearchParameters</code>, and returns a new <code class="CodeMirror cm-s-default">SearchParameters</code>. The <code class="CodeMirror cm-s-default">SearchParameters</code> type is described in the <a href="https://community.algolia.com/algoliasearch-helper-js/reference.html#searchparameters">Helper&#39;s documentation</a>.</p>
<p>Every time the props or state of a widget change, all the <code class="CodeMirror cm-s-default">getSearchParameters</code> methods of all the registered widgets are called in a chain to produce a new <code class="CodeMirror cm-s-default">SearchParameters</code>. Then, if the output <code class="CodeMirror cm-s-default">SearchParameters</code> differs from the previous one, a new search is triggered.</p>
<p>As such, the <code class="CodeMirror cm-s-default">getSearchParameters</code> method allows you to describe how the state and props of a widget should affect the search parameters.</p>
<pre class="CodeMirror cm-s-default"><code><span class="cm-keyword">const</span> <span class="cm-def">CoolWidget</span> <span class="cm-operator">=</span> <span class="cm-variable">createConnector</span>({
  <span class="cm-comment">// displayName, getProps, refine</span>

  <span class="cm-property">getSearchParameters</span>(<span class="cm-def">searchParameters</span>, <span class="cm-def">props</span>, <span class="cm-def">state</span>) {
    <span class="cm-comment">// Since the `queryAndPage` state entry isn&#39;t necessarily defined, we need</span>
    <span class="cm-comment">// default its value.</span>
    <span class="cm-keyword">const</span> [<span class="cm-def">query</span>, <span class="cm-def">page</span>] <span class="cm-operator">=</span> <span class="cm-variable-2">state</span>.<span class="cm-property">queryAndPage</span> <span class="cm-operator">||</span> [<span class="cm-string">&#39;&#39;</span>, <span class="cm-number">0</span>];

    <span class="cm-comment">// When the `queryAndPage` state entry changes, update the query and page of</span>
    <span class="cm-comment">// search.</span>
    <span class="cm-keyword">return</span> <span class="cm-variable-2">searchParameters</span>
      .<span class="cm-property">setQuery</span>(<span class="cm-variable-2">query</span>)
      .<span class="cm-property">setPage</span>(<span class="cm-variable-2">page</span>);
  },
})(<span class="cm-variable">Widget</span>);</code></pre><h3 id="getmetadata-props-state-">getMetadata(props, state)</h3>
<p>This method allows the widget to register a custom <code class="CodeMirror cm-s-default">metadata</code> object for any props and state combination.</p>
<p>If your widget is stateful, the corresponding URL key should be declared on the metadata object as the <code class="CodeMirror cm-s-default">id</code> property, so that the <code class="CodeMirror cm-s-default">InstantSearch</code> component can determine which URL keys it controls and which are foreign and should be left intact.</p>
<p>The metadata object also allows you to declare any data that you would like to pass down to all other widgets. The list of metadata objects of all components is available as the fourth argument to the <code class="CodeMirror cm-s-default">getProps</code> method.</p>
<p>The <code class="CodeMirror cm-s-default">CurrentFilters</code> widget leverages this mechanism in order to allow any widget to declare the filters it has applied. If you want to add your own filter, declare a <code class="CodeMirror cm-s-default">filters</code> property on your widget&#39;s metadata object:</p>
<pre class="CodeMirror cm-s-default"><code><span class="cm-keyword">const</span> <span class="cm-def">CoolWidget</span> <span class="cm-operator">=</span> <span class="cm-variable">createConnector</span>({
  <span class="cm-comment">// displayName, getProps, refine, getSearchParameters</span>

  <span class="cm-property">getMetadata</span>(<span class="cm-def">props</span>, <span class="cm-def">state</span>) {
    <span class="cm-comment">// Since the `queryAndPage` state entry isn&#39;t necessarily defined, we need</span>
    <span class="cm-comment">// default its value.</span>
    <span class="cm-keyword">const</span> [<span class="cm-def">query</span>, <span class="cm-def">page</span>] <span class="cm-operator">=</span> <span class="cm-variable-2">state</span>.<span class="cm-property">queryAndPage</span> <span class="cm-operator">||</span> [<span class="cm-string">&#39;&#39;</span>, <span class="cm-number">0</span>];

    <span class="cm-keyword">const</span> <span class="cm-def">filters</span> <span class="cm-operator">=</span> [];
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">query</span> <span class="cm-operator">!==</span> <span class="cm-string">&#39;&#39;</span>) {
      <span class="cm-variable-2">filters</span>.<span class="cm-property">push</span>({
        <span class="cm-comment">// Unique identifier for this filter.</span>
        <span class="cm-property">key</span>: <span class="cm-string-2">`queryAndPage.query`</span>,
        <span class="cm-comment">// String label (or node) that should appear in the CurrentFilters</span>
        <span class="cm-comment">// component.</span>
        <span class="cm-property">label</span>: <span class="cm-string-2">`Query: ${</span><span class="cm-variable-2">query</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>,
        <span class="cm-comment">// Describes how clearing this filter affects the InstantSearch state.</span>
        <span class="cm-comment">// In our case, clearing the query just resets it to an empty string</span>
        <span class="cm-comment">// without affecting the page.</span>
        <span class="cm-property">clear</span>: <span class="cm-def">nextState</span> <span class="cm-operator">=&gt;</span> {
          <span class="cm-keyword">return</span> {
            <span class="cm-meta">...</span><span class="cm-variable-2">nextState</span>,
            <span class="cm-comment">// Do not depend on the current `state` here. Since filters can be</span>
            <span class="cm-comment">// cleared in batches, the `state` parameter is not up-to-date when</span>
            <span class="cm-comment">// this method is called.</span>
            <span class="cm-variable">queryAndPage</span>: [<span class="cm-string">&#39;&#39;</span>, <span class="cm-variable-2">nextState</span>.<span class="cm-variable">queryAndPage</span>[<span class="cm-number">1</span>]],
          };
        },
      });
    }

    <span class="cm-keyword">if</span> (<span class="cm-variable-2">page</span> <span class="cm-operator">!==</span> <span class="cm-number">0</span>) {
      <span class="cm-variable-2">filters</span>.<span class="cm-property">push</span>({
        <span class="cm-property">key</span>: <span class="cm-string-2">`queryAndPage.page`</span>,
        <span class="cm-property">label</span>: <span class="cm-string-2">`Page: ${</span><span class="cm-variable-2">page</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>,
        <span class="cm-property">clear</span>: <span class="cm-def">nextState</span> <span class="cm-operator">=&gt;</span> {
          <span class="cm-keyword">return</span> {
            <span class="cm-meta">...</span><span class="cm-variable-2">nextState</span>,
            <span class="cm-variable">queryAndPage</span>: [<span class="cm-variable-2">nextState</span>.<span class="cm-variable">queryAndPage</span>[<span class="cm-number">0</span>], <span class="cm-number">0</span>],
          };
        },
      });
    }

    <span class="cm-keyword">return</span> {
      <span class="cm-comment">// This widget manipulates the `queryAndPage` state entry.</span>
      <span class="cm-property">id</span>: <span class="cm-string">&#39;queryAndPage&#39;</span>,
      <span class="cm-property">filters</span>,
    };
  },
})(<span class="cm-variable">Widget</span>);</code></pre>
    </div>

    <script type="text/javascript" src="assets/entry.js"></script>
    
      <script src="http://localhost:35729/livereload.js"></script>
    
  </body>
</html>
